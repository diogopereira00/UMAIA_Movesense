const db = require("../lib/db.js");
const async = require("async");
const _ = require("lodash");

const chunkSize = 100;
module.exports.addAccData = (req, res, next) => {
	let accs = JSON.parse(req.body.jsonString);
	let chunks = _.chunk(accs, chunkSize);
	async.eachSeries(
		chunks,
		(accChunk, callback) => {
			db.query(
				`INSERT IGNORE INTO acc_table (id_on_phone, user_id, x, y, z, timestamp, created_at) VALUES ?`,
				[
					accChunk.map((acc) => [
						acc.id,
						acc.userID,
						acc.x,
						acc.y,
						acc.z,
						acc.timestamp,
						new Date(acc.created).toISOString().slice(0, 19).replace("T", " "),
					]),
				],
				(err, ress) => {
					if (err) {
						callback(err);
					} else {
						callback();
					}
				}
			);
		},
		(err) => {
			if (err) {
				return res.status(401).send({
					msg: "Erro",
				});
			}
			return res.status(200).send({
				msg: "Dados adicionados",
			});
		}
	);
};

module.exports.addGyroData = (req, res, next) => {
	let gyros = JSON.parse(req.body.jsonString);
	let chunks = _.chunk(gyros, chunkSize);
	async.eachSeries(
		chunks,
		(gyroChunk, callback) => {
			db.query(
				`INSERT IGNORE INTO gyro_table (id_on_phone, user_id, x, y, z, timestamp, created_at) VALUES ?`,
				[
					gyroChunk.map((gyro) => [
						gyro.id,
						gyro.userID,
						gyro.x,
						gyro.y,
						gyro.z,
						gyro.timestamp,
						new Date(gyro.created).toISOString().slice(0, 19).replace("T", " "),
					]),
				],
				(err, ress) => {
					if (err) {
						callback(err);
					} else {
						callback();
					}
				}
			);
		},
		(err) => {
			if (err) {
				return res.status(401).send({
					msg: "Erro",
				});
			}
			return res.status(200).send({
				msg: "Dados adicionados",
			});
		}
	);
};

module.exports.addMagnData = (req, res, next) => {
	let magns = JSON.parse(req.body.jsonString);
	let chunks = _.chunk(magns, chunkSize);
	async.eachSeries(
		chunks,
		(magnChunk, callback) => {
			db.query(
				`INSERT IGNORE INTO magn_table (id_on_phone, user_id, x, y, z, timestamp, created_at) VALUES ?`,
				[
					magnChunk.map((magn) => [
						magn.id,
						magn.userID,
						magn.x,
						magn.y,
						magn.z,
						magn.timestamp,
						new Date(magn.created).toISOString().slice(0, 19).replace("T", " "),
					]),
				],
				(err, ress) => {
					if (err) {
						callback(err);
					} else {
						callback();
					}
				}
			);
		},
		(err) => {
			if (err) {
				return res.status(401).send({
					msg: "Erro",
				});
			}
			return res.status(200).send({
				msg: "Dados adicionados",
			});
		}
	);
};

module.exports.addECGData = (req, res, next) => {
	let ecgs = JSON.parse(req.body.jsonString);
	let chunks = _.chunk(ecgs, chunkSize);
	async.eachSeries(
		chunks,
		(ecgChunk, callback) => {
			db.query(
				`INSERT IGNORE INTO ecg_table (id_on_phone, user_id, data, timestamp, created_at) VALUES ?`,
				[
					ecgChunk.map((ecg) => [
						ecg.id,
						ecg.userID,
						ecg.data,
						ecg.timestamp,
						new Date(ecg.created).toISOString().slice(0, 19).replace("T", " "),
					]),
				],
				(err, ress) => {
					if (err) {
						callback(err);
					} else {
						callback();
					}
				}
			);
		},
		(err) => {
			if (err) {
				return res.status(401).send({
					msg: "Erro",
				});
			}
			return res.status(200).send({
				msg: "Dados adicionados",
			});
		}
	);
};

module.exports.addHRData = (req, res, next) => {
	let hrs = JSON.parse(req.body.jsonString);
	let chunks = _.chunk(hrs, chunkSize);
	async.eachSeries(
		chunks,
		(hrsChunk, callback) => {
			db.query(
				`INSERT IGNORE INTO hr_table (id_on_phone, user_id, average, rr_data, created_at) VALUES ?`,
				[hrsChunk.map((hr) => [hr.id, hr.userID, hr.average, hr.rrData, new Date(hr.created).toISOString().slice(0, 19).replace("T", " ")])],
				(err, ress) => {
					if (err) {
						callback(err);
					} else {
						callback();
					}
				}
			);
		},
		(err) => {
			if (err) {
				return res.status(401).send({
					msg: "Erro",
				});
			}
			return res.status(200).send({
				msg: "Dados adicionados",
			});
		}
	);
};

module.exports.addTempData = (req, res, next) => {
	console.log(req.headers);
	let temps = JSON.parse(req.body.jsonString);
	let chunks = _.chunk(temps, chunkSize);
	async.eachSeries(
		chunks,
		(tempsChunk, callback) => {
			db.query(
				`INSERT IGNORE INTO temp_table (id_on_phone, user_id, measurement, timestamp, created_at) VALUES ?`,
				[
					tempsChunk.map((temp) => [
						temp.id,
						temp.userID,
						temp.measurement,
						temp.timestamp,
						new Date(temp.created).toISOString().slice(0, 19).replace("T", " "),
					]),
				],
				(err, ress) => {
					if (err) {
						callback(err);
					} else {
						callback();
					}
				}
			);
		},
		(err) => {
			if (err) {
				return res.status(401).send({
					msg: "Erro",
				});
			}
			return res.status(200).send({
				msg: "Dados adicionados",
			});
		}
	);
};

// const chunkSize = 10000;

module.exports.addAllData = (req, res, next) => {
	// Get sensor data from request body
	console.log(req.body.accList.length);
	let accList = req.body.accList;
	let magnList = req.body.magnList;
	let gyroList = req.body.gyroList;
	let ecgList = req.body.ecgList;
	let hrList = req.body.hrList;
	let tempList = req.body.tempList;

	db.getConnection((err, connection) => {
		if (err) {
			console.error("Error getting connection:", err);
			return res.status(500).send("Internal Server Error");
		}

		// Promise for accelerometer data insertion
		// Promise for accelerometer data insertion
		const accPromise = new Promise((resolve, reject) => {
			// Start a new transaction for accelerometer data
			if (typeof accList !== "undefined" && accList.length > 0) {
				let chunks = _.chunk(accList, chunkSize);
				console.log("Number of accelerometer chunks: " + chunks.length);

				connection.beginTransaction(function (err) {
					if (err) {
						console.error("Error starting transaction:", err);
						return reject("Internal Server Error");
					}

					async.eachSeries(
						chunks,
						(accChunk, callback) => {
							connection.query(
								`INSERT IGNORE INTO acc_table (id_on_phone, user_id, x, y, z, timestamp, created_at) VALUES ?`,
								[
									accChunk.map((acc) => [
										acc.id,
										acc.userID,
										acc.x,
										acc.y,
										acc.z,
										acc.timestamp,
										new Date(acc.created).toISOString().slice(0, 19).replace("T", " "),
									]),
								],
								function (err, result) {
									if (err) {
										console.error("Error inserting accelerometer data:", err);
										return connection.rollback(function () {
											reject("Internal Server Error");
										});
									}
									console.log("Accelerometer data inserted:", result.affectedRows);
									callback();
								}
							);
						},
						function (err) {
							if (err) {
								console.error("Error inserting accelerometer data:", err);
								return connection.rollback(function () {
									reject("Internal Server Error");
								});
							}

							// Commit the transaction for accelerometer data
							connection.commit(function (err) {
								if (err) {
									console.error("Error committing transaction:", err);
									return connection.rollback(function () {
										reject("Internal Server Error");
									});
								}
								console.log("Accelerometer transaction committed successfully.");
								resolve("Accelerometer data inserted successfully");
							});
						}
					);
				});
			} else {
				// If there is no accelerometer data to insert, resolve the promise immediately
				resolve();
			}
		});

		// Promise for gyro data insertion
		const gyroPromise = new Promise((resolve, reject) => {
			// Start a new transaction for accelerometer data
			if (typeof gyroList !== "undefined" && gyroList.length > 0) {
				let chunks = _.chunk(gyroList, chunkSize);
				console.log("Number of gyro chunks: " + chunks.length);

				connection.beginTransaction(function (err) {
					if (err) {
						console.error("Error starting transaction:", err);
						return reject("Internal Server Error");
					}

					async.eachSeries(
						chunks,
						(gyroChunk, callback) => {
							connection.query(
								`INSERT IGNORE INTO gyro_table (id_on_phone, user_id, x, y, z, timestamp, created_at) VALUES ?`,
								[
									gyroChunk.map((gyro) => [
										gyro.id,
										gyro.userID,
										gyro.x,
										gyro.y,
										gyro.z,
										gyro.timestamp,
										new Date(gyro.created).toISOString().slice(0, 19).replace("T", " "),
									]),
								],
								function (err, result) {
									if (err) {
										console.error("Error inserting gyro data:", err);
										return connection.rollback(function () {
											reject("Internal Server Error");
										});
									}
									console.log("Gyro data inserted:", result.affectedRows);
									callback();
								}
							);
						},
						function (err) {
							if (err) {
								console.error("Error inserting gyro data:", err);
								return connection.rollback(function () {
									reject("Internal Server Error");
								});
							}

							// Commit the transaction for accelerometer data
							connection.commit(function (err) {
								if (err) {
									console.error("Error committing transaction:", err);
									return connection.rollback(function () {
										reject("Internal Server Error");
									});
								}
								console.log("Gyro transaction committed successfully.");
								resolve("Gyro data inserted successfully");
							});
						}
					);
				});
			} else {
				// If there is no accelerometer data to insert, resolve the promise immediately
				resolve();
			}
		});

		// Promise for gyro data insertion
		const magnPromise = new Promise((resolve, reject) => {
			// Start a new transaction for accelerometer data
			if (typeof magnList !== "undefined" && magnList.length > 0) {
				let chunks = _.chunk(magnList, chunkSize);
				console.log("Number of magn chunks: " + chunks.length);

				connection.beginTransaction(function (err) {
					if (err) {
						console.error("Error starting transaction:", err);
						return reject("Internal Server Error");
					}

					async.eachSeries(
						chunks,
						(magnChunk, callback) => {
							connection.query(
								`INSERT IGNORE INTO magn_table (id_on_phone, user_id, x, y, z, timestamp, created_at) VALUES ?`,
								[
									magnChunk.map((magn) => [
										magn.id,
										magn.userID,
										magn.x,
										magn.y,
										magn.z,
										magn.timestamp,
										new Date(magn.created).toISOString().slice(0, 19).replace("T", " "),
									]),
								],
								function (err, result) {
									if (err) {
										console.error("Error inserting gyro data:", err);
										return connection.rollback(function () {
											reject("Internal Server Error");
										});
									}
									console.log("Magn data inserted:", result.affectedRows);
									callback();
								}
							);
						},
						function (err) {
							if (err) {
								console.error("Error inserting magn data:", err);
								return connection.rollback(function () {
									reject("Internal Server Error");
								});
							}

							// Commit the transaction for accelerometer data
							connection.commit(function (err) {
								if (err) {
									console.error("Error committing transaction:", err);
									return connection.rollback(function () {
										reject("Internal Server Error");
									});
								}
								console.log("Magn transaction committed successfully.");
								resolve("Magn data inserted successfully");
							});
						}
					);
				});
			} else {
				// If there is no accelerometer data to insert, resolve the promise immediately
				resolve();
			}
		});

		// Promise for ECG data insertion
		const ecgPromise = new Promise((resolve, reject) => {
			// Start a new transaction for ECG data
			if (typeof ecgList !== "undefined" && ecgList.length > 0) {
				let chunks = _.chunk(ecgList, chunkSize);
				console.log("Number of ECG chunks: " + chunks.length);

				connection.beginTransaction(function (err) {
					if (err) {
						console.error("Error starting transaction:", err);
						return reject(err);
					}

					async.eachSeries(
						chunks,
						(ecgChunk, callback) => {
							connection.query(
								`INSERT IGNORE INTO ecg_table (id_on_phone, user_id, data, timestamp, created_at) VALUES ?`,
								[
									ecgChunk.map((ecg) => [
										ecg.id,
										ecg.userID,
										ecg.data,
										ecg.timestamp,
										new Date(ecg.created).toISOString().slice(0, 19).replace("T", " "),
									]),
								],
								function (err, result) {
									if (err) {
										console.error("Error inserting ECG data:", err);
										return connection.rollback(function () {
											reject(err);
										});
									}
									console.log("ECG data inserted:", result.affectedRows);
									callback();
								}
							);
						},
						function (err) {
							if (err) {
								console.error("Error inserting ECG data:", err);
								return connection.rollback(function () {
									reject(err);
								});
							}
							// Commit the transaction for ECG data
							connection.commit(function (err) {
								if (err) {
									console.error("Error committing transaction for ECG data:", err);
									return connection.rollback(function () {
										reject(err);
									});
								}
								console.log("Transaction for ECG data committed successfully.");
								resolve("ECG data inserted successfully");
							});
						}
					);
				});
			} else {
				resolve("No ECG data to insert");
			}
		});

		// Promise for HR data insertion
		const hrPromise = new Promise((resolve, reject) => {
			// Start a new transaction for ECG data
			if (typeof hrList !== "undefined" && hrList.length > 0) {
				let chunks = _.chunk(hrList, chunkSize);
				console.log("Number of HR chunks: " + chunks.length);

				connection.beginTransaction(function (err) {
					if (err) {
						console.error("Error starting transaction:", err);
						return reject(err);
					}

					async.eachSeries(
						chunks,
						(hrChunk, callback) => {
							connection.query(
								`INSERT IGNORE INTO hr_table (id_on_phone, user_id, average, rr_data, created_at) VALUES ?`,
								[
									hrChunk.map((hr) => [
										hr.id,
										hr.userID,
										hr.average,
										hr.rrData,
										new Date(hr.created).toISOString().slice(0, 19).replace("T", " "),
									]),
								],
								function (err, result) {
									if (err) {
										console.error("Error inserting HR data:", err);
										return connection.rollback(function () {
											reject(err);
										});
									}
									console.log("HR data inserted:", result.affectedRows);
									callback();
								}
							);
						},
						function (err) {
							if (err) {
								console.error("Error inserting HR data:", err);
								return connection.rollback(function () {
									reject(err);
								});
							}
							// Commit the transaction for ECG data
							connection.commit(function (err) {
								if (err) {
									console.error("Error committing transaction for HR data:", err);
									return connection.rollback(function () {
										reject(err);
									});
								}
								console.log("Transaction for HR data committed successfully.");
								resolve("HR data inserted successfully");
							});
						}
					);
				});
			} else {
				resolve("No HR data to insert");
			}
		});

		// Promise for TEMP data insertion
		const tempPromise = new Promise((resolve, reject) => {
			// Start a new transaction for ECG data
			if (typeof tempList !== "undefined" && tempList.length > 0) {
				let chunks = _.chunk(tempList, chunkSize);
				console.log("Number of TEMP chunks: " + chunks.length);

				connection.beginTransaction(function (err) {
					if (err) {
						console.error("Error starting transaction:", err);
						return reject(err);
					}

					async.eachSeries(
						chunks,
						(tempChunk, callback) => {
							connection.query(
								`INSERT IGNORE INTO temp_table (id_on_phone, user_id, measurement, timestamp, created_at) VALUES ?`,
								[
									tempChunk.map((temp) => [
										temp.id,
										temp.userID,
										temp.measurement,
										temp.timestamp,
										new Date(temp.created).toISOString().slice(0, 19).replace("T", " "),
									]),
								],
								function (err, result) {
									if (err) {
										console.error("Error inserting TEMP data:", err);
										return connection.rollback(function () {
											reject(err);
										});
									}
									console.log("TEMP data inserted:", result.affectedRows);
									callback();
								}
							);
						},
						function (err) {
							if (err) {
								console.error("Error inserting TEMP data:", err);
								return connection.rollback(function () {
									reject(err);
								});
							}
							// Commit the transaction for TEMP data
							connection.commit(function (err) {
								if (err) {
									console.error("Error committing transaction for TEMP data:", err);
									return connection.rollback(function () {
										reject(err);
									});
								}
								console.log("Transaction for TEMP data committed successfully.");
								resolve("TEMP data inserted successfully");
							});
						}
					);
				});
			} else {
				resolve("No TEMP data to insert");
			}
		});

		Promise.all([accPromise, ecgPromise, magnPromise, gyroPromise, hrPromise, tempPromise])
			.then((values) => {
				console.log(values);
				// Close connection
				connection.release();
				res.status(200).json({ message: "Data inserted successfully" });
			})
			.catch((error) => {
				console.error("Error inserting data:", error);
				// Rollback transaction and close connection
				connection.rollback(function () {
					connection.release();
					res.status(500).send("Internal Server Error");
				});
			});
	});
};
